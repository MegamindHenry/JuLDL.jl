var documenterSearchIndex = {"docs":
[{"location":"man/all_manual/","page":"All Manual","title":"All Manual","text":"CurrentModule = JuLDL","category":"page"},{"location":"man/all_manual/","page":"All Manual","title":"All Manual","text":"","category":"page"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"CurrentModule = JuLDL","category":"page"},{"location":"man/make_semantic_matrix/#Make-Semantic-Matrix","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"","category":"section"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  PS_Matrix_Struct","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.PS_Matrix_Struct","page":"Make Semantic Matrix","title":"JuLDL.PS_Matrix_Struct","text":"This a struct that store all information about prelinguistic and their feature indices. pS is the cue matrix f2i is the dictionary return indices giving features i2f is in another hand return features when giving indices\n\n\n\n\n\n","category":"type"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_pS_matrix","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_pS_matrix","page":"Make Semantic Matrix","title":"JuLDL.make_pS_matrix","text":"This is the function that make prelinguistic semantic matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_S_matrix","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_S_matrix","page":"Make Semantic Matrix","title":"JuLDL.make_S_matrix","text":"This is the function that make simulated semantic matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_pS_matrix(::DataFrame)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_pS_matrix-Tuple{DataFrames.DataFrame}","page":"Make Semantic Matrix","title":"JuLDL.make_pS_matrix","text":"makepSmatrix(::DataFrame)\n\nThis is a function that create prelinguistic matrix giving a csv file.\n\n...\n\nArguments\n\ncol_name::Symbol=:CommunicativeIntention: the column name for communicative intention\nsep_token::String=\"_\": the seperated token in the communicative intention column\n\nExamples\n\nutterance = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"utterance_mini.csv\")))\ns_obj_train = JuLDL.make_pS_matrix(utterance)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_pS_matrix(::DataFrame, ::PS_Matrix_Struct)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_pS_matrix-Tuple{DataFrames.DataFrame,JuLDL.PS_Matrix_Struct}","page":"Make Semantic Matrix","title":"JuLDL.make_pS_matrix","text":"makepSmatrix(::DataFrame, PSMatrixStruct)\n\nThis is a function that construct prelinguistic matrix giving utterances and training sobj. The feature indices should maintain the same as thoes in sobj.\n\n...\n\nArguments\n\ncol_name::Symbol=:CommunicativeIntention: the column name for communicative intention\nsep_token::String=\"_\": the seperated token in the communicative intention column\n\nExamples\n\nutterance = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"utterance_mini.csv\")))\ns_obj_train = JuLDL.make_pS_matrix(utterance)\ns_obj_val = JuLDL.make_pS_matrix(utterance_val, s_obj_train)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_S_matrix(::DataFrame, ::Vector, ::Vector)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_S_matrix-Tuple{DataFrames.DataFrame,Array{T,1} where T,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JuLDL.make_S_matrix","text":"makeSmatrix(::DataFrame, ::Vector, ::Vector)\n\nThis is a function that create simulated semantic matrix. Give each feature a random semantic vector, and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_inflection_mean::Int64=1: the sd mean of inflectional features\nsd_base::Int64=4: the sd of base features\nsd_inflection::Int64=4: the sd of inflectional features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if in deep mode, mean of each feature is also randomized \nadd_noise::Bool=true: whether to add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nisnormalize::Bool=false: if normalized, values of matrix maintain close between 1 and -1\n\nExamples\n\n# Examples\nfrench = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"french_mini.csv\")))\nS_train = JuLDL.make_S_matrix(\n  french,\n  [\"Lexeme\"],\n  [\"Tense\",\"Aspect\",\"Person\",\"Number\",\"Gender\",\"Class\",\"Mood\"])\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_S_matrix(::DataFrame, ::DataFrame, ::Vector, ::Vector)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_S_matrix-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{T,1} where T,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JuLDL.make_S_matrix","text":"makeSmatrix(::DataFrame, ::DataFrame, ::Vector, ::Vector)\n\nThis is a function that create validation simulated semantic matrix. Give each feature a random semantic vector, and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_inflection_mean::Int64=1: the sd mean of inflectional features\nsd_base::Int64=4: the sd of base features\nsd_inflection::Int64=4: the sd of inflectional features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if in deep mode, mean of each feature is also randomized \nadd_noise::Bool=true: whether to add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nisnormalize::Bool=false: if normalized, values of matrix maintain close between 1 and -1\n\nExamples\n\n# Examples\nfrench = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"french_mini.csv\")))\nfrench_val = french[100:end,:]\nS_train, S_val = JuLDL.make_S_matrix(\n    french,\n    french_val,\n    [\"Lexeme\"],\n    [\"Tense\",\"Aspect\",\"Person\",\"Number\",\"Gender\",\"Class\",\"Mood\"])\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_S_matrix(::DataFrame)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_S_matrix-Tuple{DataFrames.DataFrame}","page":"Make Semantic Matrix","title":"JuLDL.make_S_matrix","text":"makeSmatrix(::DataFrame)\n\nThis is a function that create simulated semantic matrix, provided for dataset that only have base features. Give each feature a random semantic vector, and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nbase::Vector=[\"Lexeme\"]: the base features \nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_base::Int64=4: the sd of base features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if in deep mode, mean of each feature is also randomized \nadd_noise::Bool=true: whether to add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\n\nExamples\n\nfrench = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"french_mini.csv\")))\n\nS_train = JuLDL.make_S_matrix(\n  french,\n  base=[\"Lexeme\"])=\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  make_S_matrix(::DataFrame, ::DataFrame)","category":"page"},{"location":"man/make_semantic_matrix/#JuLDL.make_S_matrix-Tuple{DataFrames.DataFrame,DataFrames.DataFrame}","page":"Make Semantic Matrix","title":"JuLDL.make_S_matrix","text":"makeSmatrix(::DataFrame, ::DataFrame)\n\nThis is a function that create validation simulated semantic matrix, provided for dataset that only have base features. Give each feature a random semantic vector, and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nbase::Vector=[\"Lexeme\"]: the base features \nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_base::Int64=4: the sd of base features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if in deep mode, mean of each feature is also randomized \nadd_noise::Bool=true: whether to add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\n\nExamples\n\nfrench = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"french_mini.csv\")))\nfrench_val = french[100:end,:]\nS_train, S_val = JuLDL.make_S_matrix(\n    french,\n    french_val,\n    base=[\"Lexeme\"])\n\n...\n\n\n\n\n\n","category":"method"},{"location":"#Package-Guilds","page":"Home","title":"Package Guilds","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documenter can be installed using the Julia package manager vie GitHub HTTPS Links. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/MegamindHenry/JuLDL.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\npynld mode methods is not tested yet!","category":"page"},{"location":"#Someother-sections","page":"Home","title":"Someother sections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"some other docs","category":"page"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"CurrentModule = JuLDL","category":"page"},{"location":"man/make_cue_matrix/#Make-Cue-Matrix","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"","category":"section"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"  Cue_Matrix_Struct","category":"page"},{"location":"man/make_cue_matrix/#JuLDL.Cue_Matrix_Struct","page":"Make Cue Matrix","title":"JuLDL.Cue_Matrix_Struct","text":"a struct that store info after makecuematrix C is the cue matrix f2i is the dictionary return indices giving features i2f is in another hand return features when giving indices gold_ind stores gold paths within a list of indices A is the adjacency matrix\n\n\n\n\n\n","category":"type"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"  make_cue_matrix(::DataFrame)","category":"page"},{"location":"man/make_cue_matrix/#JuLDL.make_cue_matrix-Tuple{DataFrames.DataFrame}","page":"Make Cue Matrix","title":"JuLDL.make_cue_matrix","text":"makecuematrix(::DataFrame)\n\nThis function make cue matrix and corresponding indices giving dataset as csv file.\n\n...\n\nArguments\n\ngrams::Int64=3: the number of grams for cues \nwords_column::Union{String, Symbol}=:Words: the column name for word\ntokenized::Bool=false: whether the word is tokenized\nsep_token::Union{Nothing, String, Char}=nothing: what is the seperate token\nkeep_sep::Bool=false: whether to keep seperater in cues\nstart_end_token::Union{String, Char}=\"#\": start and end token\nverbose::Bool=false: if verbose, more information prints out\n\n...\n\nlatin = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"latin_mini.csv\")))\nlatin_cue_obj_train = JuLDL.make_cue_matrix(\n  latin,\n  grams=3,\n  words_column=:Word,\n  tokenized=false,\n  keep_sep=false\n  )\n\n\n\n\n\n","category":"method"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"  make_cue_matrix(::DataFrame,::Cue_Matrix_Struct)","category":"page"},{"location":"man/make_cue_matrix/#JuLDL.make_cue_matrix-Tuple{DataFrames.DataFrame,JuLDL.Cue_Matrix_Struct}","page":"Make Cue Matrix","title":"JuLDL.make_cue_matrix","text":"makecuematrix(::DataFrame,::CueMatrixStruct)\n\nThis function make cue matrix and corresponding indices giving dataset as csv file and train dataset cue obj. This is often used to construct valcueobj, in order to maintain the same indices.\n\n...\n\nArguments\n\ngrams::Int64=3: the number of grams for cues \nwords_column::Union{String, Symbol}=:Words: the column name for word\ntokenized::Bool=false: whether the word is tokenized\nsep_token::Union{Nothing, String, Char}=nothing: what is the seperate token\nkeep_sep::Bool=false: whether to keep seperater in cues\nstart_end_token::Union{String, Char}=\"#\": start and end token\nverbose::Bool=false: if verbose, more information prints out\n\n...\n\nlatin = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"latin_mini.csv\")))\nlatin_cue_obj_train = JuLDL.make_cue_matrix(\n  latin,\n  grams=3,\n  words_column=:Word,\n  tokenized=false,\n  keep_sep=false\n  )\n# simulate the val dataset. Notice here that latin_val is part of training dataset to make\n# sure all features and n-grams covered by training dataset.\nlatin_val = latin[101:150,:]\nlatin_cue_obj_val = JuLDL.make_cue_matrix(\n  latin_val,\n  latin_cue_obj_train,\n  grams=3,\n  words_column=:Word,\n  tokenized=false,\n  keep_sep=false\n  )\n\n\n\n\n\n","category":"method"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"  make_ngrams(::Array,::Int64,::Bool,::Union{Nothing, String, Char},::Union{String, Char})","category":"page"},{"location":"man/make_cue_matrix/#JuLDL.make_ngrams-Tuple{Array,Int64,Bool,Union{Nothing, Char, String},Union{Char, String}}","page":"Make Cue Matrix","title":"JuLDL.make_ngrams","text":"make_ngrams(::Array,::Int64,::Bool,   ::Union{Nothing, String, Char},::Union{String, Char}\n\ngiven a list of tokens, return all ngrams in a list\n\n\n\n\n\n","category":"method"}]
}
